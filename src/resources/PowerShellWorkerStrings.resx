<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="https://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="https://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="RequireEntryPointForScriptModule" xml:space="preserve">
    <value>The 'entryPoint' property needs to be specified when 'scriptFile' points to a PowerShell module script file (.psm1).</value>
  </data>
  <data name="InvalidEntryPointForScriptFile" xml:space="preserve">
    <value>The 'entryPoint' property is supported only if 'scriptFile' points to a PowerShell module script file (.psm1).</value>
  </data>
  <data name="InOutBindingNotSupported" xml:space="preserve">
    <value>The binding '{0}' is declared with 'InOut' direction, which is not supported by PowerShell functions.</value>
  </data>
  <data name="MissingParameter" xml:space="preserve">
    <value>No parameter defined in the script or function for the input binding '{0}'.</value>
  </data>
  <data name="UnknownParameter" xml:space="preserve">
    <value>No input binding defined for the parameter '{0}' that is declared in the script or function.</value>
  </data>
  <data name="FailToParseScript" xml:space="preserve">
    <value>The script file '{0}' has parsing errors:
{1}</value>
  </data>
  <data name="CannotFindEntryPoint" xml:space="preserve">
    <value>Cannot find the function '{0}' defined in '{1}'.</value>
  </data>
  <data name="MultipleEntryPointFound" xml:space="preserve">
    <value>More than one functions named '{0}' are found in '{1}'.</value>
  </data>
  <data name="FunctionNotLoaded" xml:space="preserve">
    <value>Function with the ID '{0}' was not loaded.</value>
  </data>
  <data name="FunctionAppRootNotResolved" xml:space="preserve">
    <value>The FunctionApp root hasn't been resolved yet!</value>
  </data>
  <data name="FileNotFound" xml:space="preserve">
    <value>No '{0}' is found at the FunctionApp root folder: {1}.</value>
  </data>
  <data name="FailToRunProfile" xml:space="preserve">
    <value>Fail to run profile.ps1. See logs for detailed errors. Profile location: {0}.</value>
  </data>
  <data name="UnsupportedMessage" xml:space="preserve">
    <value>Unsupported message type: {0}.</value>
  </data>
  <data name="DurableFunctionNotSupported" xml:space="preserve">
    <value>Durable function is not yet supported for PowerShell.</value>
  </data>
  <data name="FailToConvertToHttpResponseContext" xml:space="preserve">
    <value>The given value for the 'http' output binding '{0}' cannot be converted to the type 'HttpResponseContext'. The conversion failed with the following error: {1}</value>
  </data>
  <data name="SpecifiedCustomPipeName" xml:space="preserve">
    <value>Custom pipe name specified. You can attach to the process by using vscode or by running `Enter-PSHostProcess -CustomPipeName {0}`</value>
  </data>
  <data name="FailToGetModuleLatestVersion" xml:space="preserve">
    <value>Fail to get latest version for module '{0}' with major version '{1}'. {2} </value>
  </data>
  <data name="FunctionAppDoesNotHaveDependentModulesToInstall" xml:space="preserve">
    <value>FunctionApp does have dependent modules to install.</value>
  </data>
  <data name="DependencyNameIsNullOrEmpty" xml:space="preserve">
    <value>Dependency name is null or empty.</value>
  </data>
  <data name="StartedInstallingModule" xml:space="preserve">
    <value>Started installing module '{0}' version '{1}'.</value>
  </data>
  <data name="ModuleHasBeenInstalled" xml:space="preserve">
    <value>Module name '{0}' version '{1}' has been installed.</value>
  </data>
  <data name="AcceptableFunctionAppDependenciesAlreadyInstalled" xml:space="preserve">
    <value>The function app has existing dependencies installed. Updating the dependencies to the latest versions will be performed in the background. New function app instances will pick up any new dependencies.</value>
  </data>
  <data name="InvalidPowerShellDataFile" xml:space="preserve">
    <value>The PowerShell data file '{0}' is invalid since it cannot be evaluated into a Hashtable object.</value>
  </data>
  <data name="InvalidVersionFormat" xml:space="preserve">
    <value>Version specification '{0}' is not in the correct format. Please specify the exact version or use the following notation: '{1}'</value>
  </data>
  <data name="FailToInstallFuncAppDependencies" xml:space="preserve">
    <value>Fail to install FunctionApp dependencies. Error: '{0}'</value>
  </data>
  <data name="FailToResolveHomeDirectory" xml:space="preserve">
    <value>Fail to resolve '{0}' path in App Service.</value>
  </data>
  <data name="InstallingFunctionAppDependentModules" xml:space="preserve">
    <value>Installing FunctionApp dependent modules to '{0}'.</value>
  </data>
  <data name="FailToClenupModuleDestinationPath" xml:space="preserve">
    <value>Fail to clean up module destination path '{0}'</value>
  </data>
  <data name="LogConcurrencyUpperBound" xml:space="preserve">
    <value>The enforced concurrency level (pool size limit) is '{0}'.</value>
  </data>
  <data name="LogNewPowerShellManagerCreated" xml:space="preserve">
    <value>A new PowerShell manager instance is added to the pool. Current pool size '{0}'.</value>
  </data>
  <data name="DependencyDownloadInProgress" xml:space="preserve">
    <value>Managed dependency download is in progress, function execution will continue when it's done.</value>
  </data>
  <data name="OutputBindingAlreadySet" xml:space="preserve">
    <value>The output binding '{0}' is already set with a value. The type of the output binding is '{1}'. It only accepts one message/record/file per a Function invocation. To override the value, use '-Clobber'.</value>
  </data>
  <data name="DontPushOutputOutsideWorkerRunspace" xml:space="preserve">
    <value>'Push-OutputBinding' should only be used in the PowerShell Language Worker's default Runspace(s). Do not use it in a custom Runsapce created during the function execution because the pushed values cannot be collected.</value>
  </data>
  <data name="BindingNameNotExist" xml:space="preserve">
    <value>The specified name '{0}' cannot be resolved to a valid output binding of this function.</value>
  </data>
  <data name="UnrecognizedBehavior" xml:space="preserve">
    <value>Unrecognized data collecting behavior '{0}'.</value>
  </data>
  <data name="FailToCreateFunctionAppDependenciesDestinationPath" xml:space="preserve">
    <value>Fail to create FunctionApp dependencies destination path '{0}'. Please make sure you have write access to this location. Error '{1}'. </value>
  </data>
  <data name="FailToInstallModule" xml:space="preserve">
    <value>Fail to install module '{0}' version '{1}'. {2} attempt. Error: '{3}'</value>
  </data>
  <data name="FirstAttempt" xml:space="preserve">
    <value>1st</value>
  </data>
  <data name="SecondAttempt" xml:space="preserve">
    <value>2nd</value>
  </data>
  <data name="ThirdAttempt" xml:space="preserve">
    <value>3rd</value>
  </data>
  <data name="ErrorDetails" xml:space="preserve">
    <value>Error: '{0}'</value>
  </data>
  <data name="DependenciesUpgradeSkippedMessage" xml:space="preserve">
    <value>Function app dependencies upgrade skipped. Error details: {0}. </value>
  </data>
  <data name="FailedToRemoveDependenciesFolder" xml:space="preserve">
    <value>Failed to remove old dependencies folder '{0}'. Error: '{1}'.</value>
  </data>
  <data name="RemovingDependenciesFolder" xml:space="preserve">
    <value>Removing dependencies folder '{0}'.</value>
  </data>
  <data name="FailedToRetrieveDependenciesFolderAccessTime" xml:space="preserve">
    <value>Failed to retrieve dependencies folder '{0}' access time. Error: '{1}'.</value>
  </data>
  <data name="UpdatingManagedDependencySnapshotHeartbeat" xml:space="preserve">
    <value>Updating dependencies folder heartbeat for '{0}''.</value>
  </data>
  <data name="FailedToInstallDependenciesSnapshot" xml:space="preserve">
    <value>Failed to install dependencies into '{0}', removing the folder.</value>
  </data>
  <data name="TooManyDependencies" xml:space="preserve">
    <value>The number of entries in the '{0}' file is {1}, which exceeds the maximum supported number of entries ({2}).</value>
  </data>
  <data name="FailedToCompareDependencySnapshots" xml:space="preserve">
    <value>Failed to compare dependency snapshots '{0}' and '{1}'. Error: '{2}'.</value>
  </data>
  <data name="RemovingEquivalentDependencySnapshot" xml:space="preserve">
    <value>Removing dependency snapshot '{0}' because it is equivalent to '{1}'.</value>
  </data>
  <data name="PromotedDependencySnapshot" xml:space="preserve">
    <value>Promoted dependency snapshot '{0}' to '{1}'.</value>
  </data>
</root>