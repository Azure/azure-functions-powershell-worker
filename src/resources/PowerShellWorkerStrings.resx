<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="https://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="https://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="RequireEntryPointForScriptModule" xml:space="preserve">
    <value>The 'entryPoint' property needs to be specified when 'scriptFile' points to a PowerShell module script file (.psm1).</value>
  </data>
  <data name="InvalidEntryPointForScriptFile" xml:space="preserve">
    <value>The 'entryPoint' property is supported only if 'scriptFile' points to a PowerShell module script file (.psm1).</value>
  </data>
  <data name="InOutBindingNotSupported" xml:space="preserve">
    <value>The binding '{0}' is declared with 'InOut' direction, which is not supported by PowerShell functions.</value>
  </data>
  <data name="MissingParameter" xml:space="preserve">
    <value>No parameter defined in the script or function for the input binding '{0}'.</value>
  </data>
  <data name="UnknownParameter" xml:space="preserve">
    <value>No input binding defined for the parameter '{0}' that is declared in the script or function.</value>
  </data>
  <data name="FailToParseScript" xml:space="preserve">
    <value>The script file '{0}' has parsing errors:
{1}</value>
  </data>
  <data name="CannotFindEntryPoint" xml:space="preserve">
    <value>Cannot find the function '{0}' defined in '{1}'.</value>
  </data>
  <data name="MultipleEntryPointFound" xml:space="preserve">
    <value>More than one functions named '{0}' are found in '{1}'.</value>
  </data>
  <data name="FunctionNotLoaded" xml:space="preserve">
    <value>Function with the ID '{0}' was not loaded.</value>
  </data>
  <data name="FunctionAppRootNotResolved" xml:space="preserve">
    <value>The FunctionApp root hasn't been resolved yet!</value>
  </data>
  <data name="FileNotFound" xml:space="preserve">
    <value>No '{0}' is found at the FunctionApp root folder: {1}.</value>
  </data>
  <data name="FailToRunProfile" xml:space="preserve">
    <value>Fail to run profile.ps1. See logs for detailed errors. Profile location: {0}.</value>
  </data>
  <data name="UnsupportedMessage" xml:space="preserve">
    <value>Unsupported message type: {0}.</value>
  </data>
  <data name="DurableFunctionNotSupported" xml:space="preserve">
    <value>Durable function is not yet supported for PowerShell.</value>
  </data>
  <data name="FailToConvertToHttpResponseContext" xml:space="preserve">
    <value>The given value for the 'http' output binding '{0}' cannot be converted to the type 'HttpResponseContext'. The conversion failed with the following error: {1}</value>
  </data>
  <data name="SpecifiedCustomPipeName" xml:space="preserve">
    <value>Custom pipe name specified. You can attach to the process by using vscode or by running `Enter-PSHostProcess -CustomPipeName {0}`</value>
  </data>
    <data name="CannotFindModuleVersion" xml:space="preserve">
    <value>Cannot find a supported version for module '{0}' with major version '{0}'.</value>
  </data>
  <data name="FunctionAppDoesNotHaveDependentModulesToInstall" xml:space="preserve">
    <value>Function App does have dependent modules to install.</value>
  </data>
  <data name="DependencyPropertyIsNullOrEmpty" xml:space="preserve">
    <value>Dependency '{0}' is null or empty.</value>
  </data>
  <data name="ModuleHasBeenInstalled" xml:space="preserve">
    <value>Module name '{0}' version '{0}' has been installed.</value>
  </data>
  <data name="LatestFunctionAppDependenciesAlreadyInstalled" xml:space="preserve">
    <value>Function app has the latest dependencies already installed.</value>
  </data>
  <data name="ManagedDependencyNotSupported" xml:space="preserve">
    <value>Managed dependency name '{0}' is not supported.</value>
  </data>
  <data name="InvalidPowerShellDataFile" xml:space="preserve">
    <value>The PowerShell data file '{0}' is invalid since it cannot be evaluated into a Hashtable object.</value>
  </data>
  <data name="InvalidVersionFormat" xml:space="preserve">
    <value>Version is not in the correct format. Please use the following notation: '{0}'</value>
  </data>
  <data name="InvalidModuleMajorVersion" xml:space="preserve">
    <value>Invalid major version for module '{0}'. The maximum available major version is '{1}'.</value>
  </data>
  <data name="FailToInstallFuncAppDependencies" xml:space="preserve">
    <value>Fail to install function app dependencies. Error: '{0}'</value>
  </data>
  <data name="FailToResolveHomeDirectory" xml:space="preserve">
    <value>Fail to resolve '{0}' path in App Service.</value>
  </data>
  <data name="InstallingFunctionAppDependentModules" xml:space="preserve">
    <value>Installing function app dependent modules.</value>
  </data>
  <data name="FailToClenupModuleDestinationPath" xml:space="preserve">
    <value>Failed to clean up module destination path '{0}'</value>
  </data>
</root>
